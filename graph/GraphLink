public class GraphLink<E> {
    protected ListLinked<Vertex<E>> listVertex;

    public GraphLink() {
        listVertex = new ListLinked<Vertex<E>>();
    }

    public void insertVertex(E data) {
        Vertex<E> v = new Vertex<>(data);
        if (listVertex.search(v) == -1) {
            listVertex.insertLast(v);
        }
    }

    public void insertEdge(E verOri, E verDes) {
        int posOri = listVertex.search(new Vertex<>(verOri));
        int posDes = listVertex.search(new Vertex<>(verDes));

        if (posOri == -1 || posDes == -1) return;

        Vertex<E> vOri = listVertex.get(posOri);
        Vertex<E> vDes = listVertex.get(posDes);

        Edge<E> edge1 = new Edge<>(vDes);
        Edge<E> edge2 = new Edge<>(vOri);

        if (vOri.listAdj.search(edge1) == -1) vOri.listAdj.insertLast(edge1);
        if (vDes.listAdj.search(edge2) == -1) vDes.listAdj.insertLast(edge2);
    }

    public String toString() {
        return this.listVertex.toString();

    }
    
    //Search Vertex
    public boolean searchVertex(E data) {
    return listVertex.search(new Vertex<>(data)) != -1;
}
    //search Edge
public boolean searchEdge(E v, E z) {
    int posV = listVertex.search(new Vertex<>(v));
    if (posV == -1) return false;
    Vertex<E> vertexV = listVertex.get(posV);
    return vertexV.listAdj.search(new Edge<>(new Vertex<>(z))) != -1;
}

//remove vertex
public void removeVertex(E data) {
    int pos = listVertex.search(new Vertex<>(data));
    if (pos == -1) return;

    Vertex<E> v = listVertex.get(pos);

    // Eliminar las aristas de otros nodos que apuntan a este
    for (int i = 0; i < listVertex.size(); i++) {
        Vertex<E> current = listVertex.get(i);
        if (!current.equals(v)) {
            current.listAdj.remove(new Edge<>(v));
        }
    }

    // Eliminar v√©rtice del grafo
    listVertex.remove(v);
}


//remove Edge
    public void removeEdge(E v, E z) {
    int posV = listVertex.search(new Vertex<>(v));
    int posZ = listVertex.search(new Vertex<>(z));
    if (posV == -1 || posZ == -1) return;

    Vertex<E> vertexV = listVertex.get(posV);
    Vertex<E> vertexZ = listVertex.get(posZ);

    vertexV.listAdj.remove(new Edge<>(vertexZ));
    vertexZ.listAdj.remove(new Edge<>(vertexV));
}

    //DFS
    public void dfs(E data) {
    boolean[] visited = new boolean[listVertex.size()];
    int startIndex = listVertex.search(new Vertex<>(data));
    if (startIndex != -1) {
        dfsRecursive(startIndex, visited);
    }
}

private void dfsRecursive(int index, boolean[] visited) {
    visited[index] = true;
    Vertex<E> v = listVertex.get(index);
    System.out.print(v.getData() + " ");

    for (int i = 0; i < v.listAdj.size(); i++) {
        Edge<E> edge = v.listAdj.get(i);
        Vertex<E> neighbor = edge.refDest;
        int neighborIndex = listVertex.search(neighbor);
        if (!visited[neighborIndex]) {
            dfsRecursive(neighborIndex, visited);
        }
    }

}

    //BFS
public void bfs(E v) {
    boolean[] visited = new boolean[listVertex.size()];
    Queue<Vertex<E>> queue = new LinkedList<>();

    int startIndex = listVertex.search(new Vertex<>(v));
    if (startIndex == -1) return;

    Vertex<E> start = listVertex.get(startIndex);
    visited[startIndex] = true;
    queue.add(start);

    while (!queue.isEmpty()) {
        Vertex<E> current = queue.poll();
        System.out.print(current.getData() + " ");

        for (int i = 0; i < current.listAdj.size(); i++) {
            Vertex<E> neighbor = current.listAdj.get(i).refDest;
            int neighborIndex = listVertex.search(neighbor);
            if (!visited[neighborIndex]) {
                visited[neighborIndex] = true;
                queue.add(neighbor);
            }
        }
    }
}




    //BFSPAHT




}

