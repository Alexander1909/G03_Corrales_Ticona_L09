public class GraphLink<E> {
    protected ListLinked<Vertex<E>> listVertex;

    public GraphLink() {
        listVertex = new ListLinked<Vertex<E>>();
    }

    public void insertVertex(E data) {
        Vertex<E> v = new Vertex<>(data);
        if (listVertex.search(v) == -1) {
            listVertex.insertLast(v);
        }
    }

    public void insertEdge(E verOri, E verDes) {
        int posOri = listVertex.search(new Vertex<>(verOri));
        int posDes = listVertex.search(new Vertex<>(verDes));

        if (posOri == -1 || posDes == -1) return;

        Vertex<E> vOri = listVertex.get(posOri);
        Vertex<E> vDes = listVertex.get(posDes);

        Edge<E> edge1 = new Edge<>(vDes);
        Edge<E> edge2 = new Edge<>(vOri);

        if (vOri.listAdj.search(edge1) == -1) vOri.listAdj.insertLast(edge1);
        if (vDes.listAdj.search(edge2) == -1) vDes.listAdj.insertLast(edge2);
    }

    public String toString() {
        return this.listVertex.toString();

    }
    
    //Search Vertex
    public boolean searchVertex(E data) {
    return listVertex.search(new Vertex<>(data)) != -1;
}
    //search Edge
public boolean searchEdge(E v, E z) {
    int posV = listVertex.search(new Vertex<>(v));
    if (posV == -1) return false;
    Vertex<E> vertexV = listVertex.get(posV);
    return vertexV.listAdj.search(new Edge<>(new Vertex<>(z))) != -1;
}

//remove vertex
public void removeVertex(E data) {
    int pos = listVertex.search(new Vertex<>(data));
    if (pos == -1) return;

    Vertex<E> v = listVertex.get(pos);

    // Eliminar las aristas de otros nodos que apuntan a este
    for (int i = 0; i < listVertex.size(); i++) {
        Vertex<E> current = listVertex.get(i);
        if (!current.equals(v)) {
            current.listAdj.remove(new Edge<>(v));
        }
    }

    // Eliminar v√©rtice del grafo
    listVertex.remove(v);
}


//remove Edge
    public void removeEdge(E v, E z) {
    int posV = listVertex.search(new Vertex<>(v));
    int posZ = listVertex.search(new Vertex<>(z));
    if (posV == -1 || posZ == -1) return;

    Vertex<E> vertexV = listVertex.get(posV);
    Vertex<E> vertexZ = listVertex.get(posZ);

    vertexV.listAdj.remove(new Edge<>(vertexZ));
    vertexZ.listAdj.remove(new Edge<>(vertexV));
}

    //DFS
    public void dfs(E data) {
    boolean[] visited = new boolean[listVertex.size()];
    int startIndex = listVertex.search(new Vertex<>(data));
    if (startIndex != -1) {
        dfsRecursive(startIndex, visited);
    }
}

private void dfsRecursive(int index, boolean[] visited) {
    visited[index] = true;
    Vertex<E> v = listVertex.get(index);
    System.out.print(v.getData() + " ");

    for (int i = 0; i < v.listAdj.size(); i++) {
        Edge<E> edge = v.listAdj.get(i);
        Vertex<E> neighbor = edge.refDest;
        int neighborIndex = listVertex.search(neighbor);
        if (!visited[neighborIndex]) {
            dfsRecursive(neighborIndex, visited);
        }
    }

}

    //BFS
public void bfs(E v) {
    boolean[] visited = new boolean[listVertex.size()];
    Queue<Vertex<E>> queue = new LinkedList<>();

    int startIndex = listVertex.search(new Vertex<>(v));
    if (startIndex == -1) return;

    Vertex<E> start = listVertex.get(startIndex);
    visited[startIndex] = true;
    queue.add(start);

    while (!queue.isEmpty()) {
        Vertex<E> current = queue.poll();
        System.out.print(current.getData() + " ");

        for (int i = 0; i < current.listAdj.size(); i++) {
            Vertex<E> neighbor = current.listAdj.get(i).refDest;
            int neighborIndex = listVertex.search(neighbor);
            if (!visited[neighborIndex]) {
                visited[neighborIndex] = true;
                queue.add(neighbor);
            }
        }
    }
}




    //BFSPAHT
public ArrayList<E> bfsPath(E start, E end) {
    Map<Vertex<E>, Vertex<E>> parent = new HashMap<>();
    boolean[] visited = new boolean[listVertex.size()];
    Queue<Vertex<E>> queue = new LinkedList<>();

    int startIndex = listVertex.search(new Vertex<>(start));
    if (startIndex == -1) return null;

    Vertex<E> startV = listVertex.get(startIndex);
    visited[startIndex] = true;
    queue.add(startV);

    while (!queue.isEmpty()) {
        Vertex<E> current = queue.poll();
        if (current.getData().equals(end)) break;

        for (int i = 0; i < current.listAdj.size(); i++) {
            Vertex<E> neighbor = current.listAdj.get(i).refDest;
            int neighborIndex = listVertex.search(neighbor);
            if (!visited[neighborIndex]) {
                visited[neighborIndex] = true;
                parent.put(neighbor, current);
                queue.add(neighbor);
            }
        }
    }

    ArrayList<E> path = new ArrayList<>();
    Vertex<E> target = new Vertex<>(end);
    int targetIndex = listVertex.search(target);
    if (targetIndex == -1 || !parent.containsKey(listVertex.get(targetIndex))) return null;

    Vertex<E> current = listVertex.get(targetIndex);
    while (current != null && !current.getData().equals(start)) {
        path.add(0, current.getData());
        current = parent.get(current);
    }
    path.add(0, start);
    return path;
}


//  insertEdgeWeight
public void insertEdgeWeight(E v, E z, int w) {
    insertVertex(v);
    insertVertex(z);

    int posV = listVertex.search(new Vertex<>(v));
    int posZ = listVertex.search(new Vertex<>(z));

    Vertex<E> vertexV = listVertex.get(posV);
    Vertex<E> vertexZ = listVertex.get(posZ);

    if (vertexV.listAdj.search(new Edge<>(vertexZ)) == -1) {
        vertexV.listAdj.insertLast(new Edge<>(vertexZ, w));
    }
    if (vertexZ.listAdj.search(new Edge<>(vertexV)) == -1) {
        vertexZ.listAdj.insertLast(new Edge<>(vertexV, w));
    }
}


// Shortpath
public ArrayList<E> shortPath(E v, E z) {
    Map<Vertex<E>, Integer> dist = new HashMap<>();
    Map<Vertex<E>, Vertex<E>> prev = new HashMap<>();
    PriorityQueue<Vertex<E>> pq = new PriorityQueue<>((a, b) -> dist.get(a) - dist.get(b));

    for (int i = 0; i < listVertex.size(); i++) {
        Vertex<E> u = listVertex.get(i);
        dist.put(u, Integer.MAX_VALUE);
        prev.put(u, null);
    }

    Vertex<E> source = listVertex.get(listVertex.search(new Vertex<>(v)));
    dist.put(source, 0);
    pq.add(source);





}

